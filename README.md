Tic-Tac-Toe Game with Tkinter GUI
This project implements a Tic-Tac-Toe game with a graphical user interface using Python's Tkinter library. The game features a player (O) versus an AI opponent (X), with a clean, modern interface and strategic AI gameplay.
Features

3×3 Game Board: A grid of buttons for gameplay.
Score Tracking: Displays scores for Player (O), AI (X), and draws.
Modern Interface: Dark blue background with color-coded elements.
Strategic AI: Plays optimally but fairly, prioritizing winning moves, blocking, and strategic positioning.

Class Structure

TicTacToeGUI: A single class handling game logic, UI setup, and AI behavior.

Initialization

Creates a 500×600 pixel window with a dark blue background.
Initializes a 9-space game board (list of blank spaces).
Configures fonts for UI elements.
Sets up:
Title label.
Score display (AI: X, Player: O, Draws).
3×3 grid of clickable buttons.
Status label for game state updates.
Control buttons (start/end game).


AI makes the first move.

Game Logic

Follows standard Tic-Tac-Toe rules:
Players alternate placing X (AI) or O (Player) on empty squares.
Win condition: Three tokens in a row (horizontal, vertical, or diagonal).
Draw condition: All squares filled without a winner.



AI Logic
The AI employs a strategic approach:

Checks for immediate winning move.
Blocks player's potential winning move.
Prioritizes strategic moves:
Takes the center if available.
Sets up potential winning patterns.
Chooses corner squares for advantage.
Falls back to side squares or random moves if no strategic option exists.



Game Flow

AI starts (typically center or corner).
Player clicks an empty square to place O.
After each move:
Game checks for a winner.
If won, highlights winning line and updates score.
If board is full without a winner, declares a draw.


Players can start a new game at any time via control buttons.

Requirements

Python 3.x
Tkinter (included with standard Python installation)

Usage

Run the Python script.
AI (X) makes the first move.
Click an empty square to place O.
Use the "New Game" button to reset or start over.

Pros

Intuitive, user-friendly interface.
Strategic AI ensures challenging yet fair gameplay.
Lightweight and easy to run.

Cons

Limited to 3×3 grid (no support for larger boards).
AI is deterministic in some scenarios, which may feel predictable.

------------------------------------------------------------------

8-Tile Puzzle with A* Search Algorithm
This projectimplements implements an 8-tile puzzle game solver usingPython, Python, utilizing utilizingthe A* search algorithmto find the optimal path to solve a randomly generated puzzle.
Description
The 8-tile puzzle consists of a 3×3 grid with 8 numbered tiles (1–8) and one empty space (represented by 0). The goal is to rearrange the tiles from a random initial state to the goal state (e.g., [[1,2,3], [4,5,6], [7,8,0]]) using the fewest moves possible.
Puzzle Generation

Generates a random arrangement of 8 tiles and an empty space.
Ensures solvability using the concept of "inversions":
Counts inversions (pairs of tilesa larger tile precedes a smaller tile in the sequence).
A puzzle is solvable if the number of inversions is even.


Only 50% of random configurations are solvable.

Search Algorithm

A Search*:
Finds the optimal path from the initial state to the goal state.
Uses a priority queue (min-heap) to manage the search frontier, prioritizing nodes with the lowest estimated total cost (f(n) = g(n) + h(n)).
g(n): Cost of the path from the start to the current node.
h(n): Heuristic estimate of the cost to reach the goal.



Heuristics

Manhattan Distance:
Calculates the sum of horizontal and vertical moves each tile is away from its goal position.
Admissible (never overestimates the true cost).
Consistent (satisfies the triangle inequality).
Ensures A* is complete and optimal for the 8-tile puzzle.



Movement

The empty space (0) can move in four directions: up, down, left, or right.
Valid neighbors are generated by swapping the empty space with an adjacent tile.

Output

Displays the randomly generated initial puzzle state.
If solvable:
Prints the number of moves required to reach the goal state.
Shows step-by-step transitions from the initial state to the goal state.


Displays the final goal state (e.g., [[1,2,3], [4,5,6], [7,8,0]]).
If unsolvable, indicates that no solution exists.

Requirements

Python 3.x
Standard libraries: heapq, random, copy

Usage

Run the Python script.
A random initial puzzle state is generated and displayed.
If solvable, the script outputs:
The number of moves to solve the puzzle.
The sequence of board states leading to the goal.


The final goal state is shown.

Pros

Optimal solution guaranteed due to A* with an admissible and consistent heuristic.
Efficient for the 8-tile puzzle with Manhattan distance.
Clear output with step-by-step transitions.

Cons

Computation time increases for complex initial states (deep search trees).
Limited to 3×3 grids (8-tile puzzle); larger grids (e.g., 15-puzzle) may require optimization.
Memory usage can grow for highly scrambled puzzles due to the priority queue.

Complexity

Time: O(b^d), where b is the branching factor (~3) and d is the depth of the solution. Worst-case exponential.
Space: O(b^d) for the priority queue and visited states.



